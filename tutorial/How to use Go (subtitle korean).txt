c드라이브 아래 GO
ex) c:\

C:\Go\src/github.com/my_id/repository name
ex ) C:\Go\src\github.com\ani8570\learngo

package 이름 작성
ex ) package main

 //////////////////////////////////
fuc main() {
}
main.go는 컴파일 만을 위해 필요

"fmt" : package for formatting 
fmt.Println 대문자로 시작하는 함수는 export 가능

var name string = "Lee"

--> name := "Lee"
 //this is sameting. but if you declared outside func,
 you have to declarared like this "var name string = "Lee"

//////////////////////////////////////

Go can return more than one.
ex) totalLength, upperName := lenAndUpper("Lee")

두개를 반환하는데 하나만 있는 건 안됨. 
ex) totalLength := lenAndUpper("Lee")
이건 됨
ex) totalLength, _ := lenAndUpper("Lee")

함수가 밑과 같다
repeatMe("nico", "lynn", "dal", "marl", "flynn")

...string으로 여러개 받는다고 알림.
func repeatMe(words ...string) {
	fmt.Println(words)
}

/////////////////////

밑에 두 함수는 같음...
2번째 함수를 naked return이라 함 ( naked : 적나라한)
func lenAndUpper(name string) (int, string) {
	return len(name), strings.ToUpper(name)
}

func lenAndUpper2(name string) (lenght int, uppercase string) {
	lenght = len(name)
	uppercase = strings.ToUpper(name)
	return
}

함수 끝나고 실행시킬 것이 있으면 defer를 사용한다.
ex) 이미지 제거, 저장, api로 요청을 보낸다거나 등등
func lenAndUpper3(name string) (lenght int, uppercase string) {
	defer fmt.Println("I'm done")
	lenght = len(name)
	uppercase = strings.ToUpper(name)
	return
}

반복문 range ->index나옴
func superAdd(numbers ...int) int {
	fmt.Println(numbers)
	for index, number := range numbers {
		fmt.Println(index, number)
	}
	return 1
	//range
}

if문 자체에서 변수 선언 가능
func canIDrink(age int) bool {
	if koreanAge := age+2 ; koreanAge < 18 {
		return false
	}	
	return true
}

switch문에서도 같음
switch koreanAge := age + 2; {
	case koreanAge < 18:
		return false
	case koreanAge == 18:
		return true

	}
	return false

Go에서도 포인터와 래퍼런스 사용 가능

배열도 사용 가능, 똑같이 0부터 접근
names := [5]string{"nico", "lynn", "dal", "marl", "flynn"}

map도 사용 가능
Lee := map[string]string{"name": "L", "age": "12"}
	fmt.Println(Lee)

for key, value := range Lee {
	fmt.Println(key, value)
}

구조체 사용가능
(외부에서 구조체 사용시 사용가능하게 하려면 대문자)
(외부에서 구조체 내부 변수 사용시 사용가능하게 하려면 대문자)
type Person struct {
	Name    string
	Age     int
	FavFood []string
}
type person struct {
	name    string
	age     int
	favFood []string
}

favFood := []string{"kimchi", "ramen"}
l := person{"Lee", 25, favFood}			can
i := person{name: "Lee", age: 18, favFood: favFood}	can
i := person{name: "Lee", 18, favFood: favFood}		can't

receiver를 가질 수 있음. 
receiver 규칙 : 구조체 이름의 첫번째 글자 소문자로 해서 받음.
func (a Account) Deposit(amount int) {

}

